var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@elizaos/core",
      version: "1.0.0-beta.20",
      description: "",
      type: "module",
      main: "dist/index.js",
      module: "dist/index.js",
      types: "dist/index.d.ts",
      exports: {
        "./package.json": "./package.json",
        ".": {
          import: {
            types: "./dist/index.d.ts",
            default: "./dist/index.js"
          }
        }
      },
      files: [
        "dist"
      ],
      scripts: {
        build: "tsup && tsc -p tsconfig.build.json",
        watch: "tsc --watch",
        clean: "rm -rf dist .turbo node_modules .turbo-tsconfig.json tsconfig.tsbuildinfo",
        dev: "tsup --watch",
        "build:docs": "cd docs && bun run build",
        test: "vitest run",
        "test:coverage": "vitest run --coverage",
        "test:watch": "vitest",
        format: "prettier --write ./src",
        "format:check": "prettier --check ./src",
        lint: "prettier --write ./src"
      },
      author: "",
      license: "MIT",
      devDependencies: {
        "@eslint/js": "9.16.0",
        "@rollup/plugin-commonjs": "25.0.8",
        "@rollup/plugin-json": "6.1.0",
        "@rollup/plugin-replace": "5.0.7",
        "@rollup/plugin-terser": "0.1.0",
        "@rollup/plugin-typescript": "11.1.6",
        "@types/mocha": "10.0.10",
        "@types/node": "^22.13.9",
        "@types/uuid": "10.0.0",
        "@typescript-eslint/eslint-plugin": "8.26.0",
        "@typescript-eslint/parser": "8.26.0",
        "@vitest/coverage-v8": "2.1.5",
        "lint-staged": "15.2.10",
        nodemon: "3.1.7",
        pm2: "5.4.3",
        prettier: "3.5.3",
        rimraf: "6.0.1",
        rollup: "2.79.2",
        "ts-node": "10.9.2",
        tslib: "2.8.1",
        tsup: "^8.4.0",
        typescript: "5.8.2"
      },
      dependencies: {
        "@types/hapi__shot": "^6.0.0",
        buffer: "^6.0.3",
        "crypto-browserify": "^3.12.1",
        dotenv: "16.4.5",
        events: "^3.3.0",
        glob: "11.0.0",
        handlebars: "^4.7.8",
        "js-sha1": "0.7.0",
        langchain: "^0.3.15",
        pino: "^9.6.0",
        "pino-pretty": "^13.0.0",
        "stream-browserify": "^3.0.0",
        "unique-names-generator": "4.7.1",
        uuid: "11.0.3"
      },
      publishConfig: {
        access: "public"
      },
      gitHead: "7b01ea21f51671371e738134c80c958483b7b709"
    };
  }
});

// src/types.ts
function asUUID(id) {
  if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    throw new Error(`Invalid UUID format: ${id}`);
  }
  return id;
}
var ModelType = {
  SMALL: "TEXT_SMALL",
  // kept for backwards compatibility
  MEDIUM: "TEXT_LARGE",
  // kept for backwards compatibility
  LARGE: "TEXT_LARGE",
  // kept for backwards compatibility
  TEXT_SMALL: "TEXT_SMALL",
  TEXT_LARGE: "TEXT_LARGE",
  TEXT_EMBEDDING: "TEXT_EMBEDDING",
  TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE",
  TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE",
  TEXT_REASONING_SMALL: "REASONING_SMALL",
  TEXT_REASONING_LARGE: "REASONING_LARGE",
  TEXT_COMPLETION: "TEXT_COMPLETION",
  IMAGE: "IMAGE",
  IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION",
  TRANSCRIPTION: "TRANSCRIPTION",
  TEXT_TO_SPEECH: "TEXT_TO_SPEECH",
  AUDIO: "AUDIO",
  VIDEO: "VIDEO",
  OBJECT_SMALL: "OBJECT_SMALL",
  OBJECT_LARGE: "OBJECT_LARGE"
};
var ServiceType = {
  TRANSCRIPTION: "transcription",
  VIDEO: "video",
  BROWSER: "browser",
  PDF: "pdf",
  REMOTE_FILES: "aws_s3",
  WEB_SEARCH: "web_search",
  EMAIL: "email",
  TEE: "tee",
  TASK: "task"
};
var MemoryType = /* @__PURE__ */ ((MemoryType2) => {
  MemoryType2["DOCUMENT"] = "document";
  MemoryType2["FRAGMENT"] = "fragment";
  MemoryType2["MESSAGE"] = "message";
  MemoryType2["DESCRIPTION"] = "description";
  MemoryType2["CUSTOM"] = "custom";
  return MemoryType2;
})(MemoryType || {});
var ChannelType = /* @__PURE__ */ ((ChannelType2) => {
  ChannelType2["SELF"] = "SELF";
  ChannelType2["DM"] = "dm";
  ChannelType2["GROUP"] = "group";
  ChannelType2["VOICE_DM"] = "VOICE_DM";
  ChannelType2["VOICE_GROUP"] = "VOICE_GROUP";
  ChannelType2["FEED"] = "FEED";
  ChannelType2["THREAD"] = "THREAD";
  ChannelType2["WORLD"] = "WORLD";
  ChannelType2["FORUM"] = "FORUM";
  ChannelType2["API"] = "API";
  return ChannelType2;
})(ChannelType || {});
var Service = class {
  /** Runtime instance */
  runtime;
  constructor(runtime) {
    if (runtime) {
      this.runtime = runtime;
    }
  }
  /** Service type */
  static serviceType;
  /** Service configuration */
  config;
  /** Start service connection */
  static async start(_runtime) {
    throw new Error("Not implemented");
  }
  /** Stop service connection */
  static async stop(_runtime) {
    throw new Error("Not implemented");
  }
};
var AgentStatus = /* @__PURE__ */ ((AgentStatus2) => {
  AgentStatus2["ACTIVE"] = "active";
  AgentStatus2["INACTIVE"] = "inactive";
  return AgentStatus2;
})(AgentStatus || {});
var KnowledgeScope = /* @__PURE__ */ ((KnowledgeScope2) => {
  KnowledgeScope2["SHARED"] = "shared";
  KnowledgeScope2["PRIVATE"] = "private";
  return KnowledgeScope2;
})(KnowledgeScope || {});
var CacheKeyPrefix = /* @__PURE__ */ ((CacheKeyPrefix2) => {
  CacheKeyPrefix2["KNOWLEDGE"] = "knowledge";
  return CacheKeyPrefix2;
})(CacheKeyPrefix || {});
var TEEMode = /* @__PURE__ */ ((TEEMode2) => {
  TEEMode2["OFF"] = "OFF";
  TEEMode2["LOCAL"] = "LOCAL";
  TEEMode2["DOCKER"] = "DOCKER";
  TEEMode2["PRODUCTION"] = "PRODUCTION";
  return TEEMode2;
})(TEEMode || {});
var TeeType = /* @__PURE__ */ ((TeeType2) => {
  TeeType2["TDX_DSTACK"] = "tdx_dstack";
  return TeeType2;
})(TeeType || {});
var Role = /* @__PURE__ */ ((Role2) => {
  Role2["OWNER"] = "OWNER";
  Role2["ADMIN"] = "ADMIN";
  Role2["NONE"] = "NONE";
  return Role2;
})(Role || {});
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["WORLD_JOINED"] = "WORLD_JOINED";
  EventType2["WORLD_CONNECTED"] = "WORLD_CONNECTED";
  EventType2["WORLD_LEFT"] = "WORLD_LEFT";
  EventType2["ENTITY_JOINED"] = "ENTITY_JOINED";
  EventType2["ENTITY_LEFT"] = "ENTITY_LEFT";
  EventType2["ENTITY_UPDATED"] = "ENTITY_UPDATED";
  EventType2["ROOM_JOINED"] = "ROOM_JOINED";
  EventType2["ROOM_LEFT"] = "ROOM_LEFT";
  EventType2["MESSAGE_RECEIVED"] = "MESSAGE_RECEIVED";
  EventType2["MESSAGE_SENT"] = "MESSAGE_SENT";
  EventType2["VOICE_MESSAGE_RECEIVED"] = "VOICE_MESSAGE_RECEIVED";
  EventType2["VOICE_MESSAGE_SENT"] = "VOICE_MESSAGE_SENT";
  EventType2["REACTION_RECEIVED"] = "REACTION_RECEIVED";
  EventType2["POST_GENERATED"] = "POST_GENERATED";
  EventType2["INTERACTION_RECEIVED"] = "INTERACTION_RECEIVED";
  EventType2["RUN_STARTED"] = "RUN_STARTED";
  EventType2["RUN_ENDED"] = "RUN_ENDED";
  EventType2["RUN_TIMEOUT"] = "RUN_TIMEOUT";
  EventType2["ACTION_STARTED"] = "ACTION_STARTED";
  EventType2["ACTION_COMPLETED"] = "ACTION_COMPLETED";
  EventType2["EVALUATOR_STARTED"] = "EVALUATOR_STARTED";
  EventType2["EVALUATOR_COMPLETED"] = "EVALUATOR_COMPLETED";
  return EventType2;
})(EventType || {});
var PlatformPrefix = /* @__PURE__ */ ((PlatformPrefix2) => {
  PlatformPrefix2["DISCORD"] = "DISCORD";
  PlatformPrefix2["TELEGRAM"] = "TELEGRAM";
  PlatformPrefix2["TWITTER"] = "TWITTER";
  return PlatformPrefix2;
})(PlatformPrefix || {});
var SOCKET_MESSAGE_TYPE = /* @__PURE__ */ ((SOCKET_MESSAGE_TYPE2) => {
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["ROOM_JOINING"] = 1] = "ROOM_JOINING";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["SEND_MESSAGE"] = 2] = "SEND_MESSAGE";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["MESSAGE"] = 3] = "MESSAGE";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["ACK"] = 4] = "ACK";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["THINKING"] = 5] = "THINKING";
  return SOCKET_MESSAGE_TYPE2;
})(SOCKET_MESSAGE_TYPE || {});
function createMessageMemory(params) {
  return {
    ...params,
    createdAt: Date.now(),
    metadata: {
      type: "message" /* MESSAGE */,
      timestamp: Date.now(),
      scope: params.agentId ? "private" : "shared"
    }
  };
}
function getTypedService(runtime, serviceType) {
  return runtime.getService(serviceType);
}
function isDocumentMetadata(metadata) {
  return metadata.type === "document" /* DOCUMENT */;
}
function isFragmentMetadata(metadata) {
  return metadata.type === "fragment" /* FRAGMENT */;
}
function isMessageMetadata(metadata) {
  return metadata.type === "message" /* MESSAGE */;
}
function isDescriptionMetadata(metadata) {
  return metadata.type === "description" /* DESCRIPTION */;
}
function isCustomMetadata(metadata) {
  return metadata.type !== "document" /* DOCUMENT */ && metadata.type !== "fragment" /* FRAGMENT */ && metadata.type !== "message" /* MESSAGE */ && metadata.type !== "description" /* DESCRIPTION */;
}
function getVideoService(runtime) {
  return runtime.getService(ServiceType.VIDEO);
}
function getBrowserService(runtime) {
  return runtime.getService(ServiceType.BROWSER);
}
function getPdfService(runtime) {
  return runtime.getService(ServiceType.PDF);
}
function getFileService(runtime) {
  return runtime.getService(ServiceType.REMOTE_FILES);
}
function isDocumentMemory(memory) {
  return memory.metadata?.type === "document" /* DOCUMENT */;
}
function isFragmentMemory(memory) {
  return memory.metadata?.type === "fragment" /* FRAGMENT */;
}
function getMemoryText(memory, defaultValue = "") {
  return memory.content.text ?? defaultValue;
}
function createServiceError(error, code = "UNKNOWN_ERROR") {
  if (error instanceof Error) {
    return {
      code,
      message: error.message,
      cause: error
    };
  }
  return {
    code,
    message: String(error)
  };
}
var VECTOR_DIMS = {
  SMALL: 384,
  MEDIUM: 512,
  LARGE: 768,
  XL: 1024,
  XXL: 1536,
  XXXL: 3072
};

// src/actions.ts
import { names, uniqueNamesGenerator } from "unique-names-generator";
var composeActionExamples = (actionsData, count) => {
  const data = actionsData.map((action) => [...action.examples]);
  const actionExamples = [];
  let length = data.length;
  for (let i = 0; i < count && length; i++) {
    const actionId = i % length;
    const examples = data[actionId];
    if (examples.length) {
      const rand = ~~(Math.random() * examples.length);
      actionExamples[i] = examples.splice(rand, 1)[0];
    } else {
      i--;
    }
    if (examples.length === 0) {
      data.splice(actionId, 1);
      length--;
    }
  }
  const formattedExamples = actionExamples.map((example) => {
    const exampleNames = Array.from(
      { length: 5 },
      () => uniqueNamesGenerator({ dictionaries: [names] })
    );
    return `
${example.map((message) => {
      let messageString = `${message.name}: ${message.content.text}${message.content.action ? ` (action: ${message.content.action})` : ""}${message.content.actions ? ` (actions: ${message.content.actions.join(", ")})` : ""}`;
      for (let i = 0; i < exampleNames.length; i++) {
        messageString = messageString.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);
      }
      return messageString;
    }).join("\n")}`;
  });
  return formattedExamples.join("\n");
};
function formatActionNames(actions) {
  return actions.sort(() => 0.5 - Math.random()).map((action) => `${action.name}`).join(", ");
}
function formatActions(actions) {
  return actions.sort(() => 0.5 - Math.random()).map((action) => `${action.name}: ${action.description}`).join(",\n");
}

// src/database.ts
var DatabaseAdapter = class {
  /**
   * The database instance.
   */
  db;
};

// src/prompts.ts
import handlebars from "handlebars";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { names as names2, uniqueNamesGenerator as uniqueNamesGenerator2 } from "unique-names-generator";

// src/logger.ts
import pino from "pino";
function parseBooleanFromText(value) {
  if (!value) return false;
  const affirmative = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"];
  const negative = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"];
  const normalizedText = value.trim().toUpperCase();
  if (affirmative.includes(normalizedText)) {
    return true;
  }
  if (negative.includes(normalizedText)) {
    return false;
  }
  return false;
}
var InMemoryDestination = class {
  logs = [];
  maxLogs = 1e3;
  // Keep last 1000 logs
  stream;
  /**
   * Constructor for creating a new instance of the class.
   * @param {DestinationStream|null} stream - The stream to assign to the instance. Can be null.
   */
  constructor(stream) {
    this.stream = stream;
  }
  /**
   * Writes a log entry to the memory buffer and forwards it to the pretty print stream if available.
   *
   * @param {string | LogEntry} data - The data to be written, which can be either a string or a LogEntry object.
   * @returns {void}
   */
  write(data) {
    let logEntry;
    let stringData;
    if (typeof data === "string") {
      stringData = data;
      try {
        logEntry = JSON.parse(data);
      } catch (e) {
        if (this.stream) {
          this.stream.write(data);
        }
        return;
      }
    } else {
      logEntry = data;
      stringData = JSON.stringify(data);
    }
    if (!logEntry.time) {
      logEntry.time = Date.now();
    }
    const isDebugMode2 = (process?.env?.LOG_LEVEL || "").toLowerCase() === "debug";
    const isLoggingDiagnostic = Boolean(process?.env?.LOG_DIAGNOSTIC);
    if (isLoggingDiagnostic) {
      logEntry.diagnostic = true;
    }
    if (!isDebugMode2) {
      if (logEntry.agentName && logEntry.agentId) {
        const msg = logEntry.msg || "";
        if (typeof msg === "string" && (msg.includes("registered successfully") || msg.includes("Registering") || msg.includes("Success:") || msg.includes("linked to") || msg.includes("Started"))) {
          if (isLoggingDiagnostic) {
            console.error("Filtered log:", stringData);
          }
          return;
        }
      }
    }
    this.logs.push(logEntry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    if (this.stream) {
      this.stream.write(stringData);
    }
  }
  /**
   * Retrieves the recent logs from the system.
   *
   * @returns {LogEntry[]} An array of LogEntry objects representing the recent logs.
   */
  recentLogs() {
    return this.logs;
  }
  /**
   * Clears all logs from memory.
   *
   * @returns {void}
   */
  clear() {
    this.logs = [];
  }
};
var customLevels = {
  fatal: 60,
  error: 50,
  warn: 40,
  info: 30,
  log: 29,
  progress: 28,
  success: 27,
  debug: 20,
  trace: 10
};
var raw = parseBooleanFromText(process?.env?.LOG_JSON_FORMAT) || false;
var isDebugMode = (process?.env?.LOG_LEVEL || "").toLowerCase() === "debug";
var effectiveLogLevel = isDebugMode ? "debug" : process?.env?.DEFAULT_LOG_LEVEL || "info";
var createPrettyConfig = () => ({
  colorize: true,
  translateTime: "yyyy-mm-dd HH:MM:ss",
  ignore: "pid,hostname",
  customPrettifiers: {
    level: (inputData) => {
      let level;
      if (typeof inputData === "object" && inputData !== null) {
        level = inputData.level || inputData.value;
      } else {
        level = inputData;
      }
      const levelNames = {
        10: "TRACE",
        20: "DEBUG",
        27: "SUCCESS",
        28: "PROGRESS",
        29: "LOG",
        30: "INFO",
        40: "WARN",
        50: "ERROR",
        60: "FATAL"
      };
      if (typeof level === "number") {
        return levelNames[level] || `LEVEL${level}`;
      }
      if (level === void 0 || level === null) {
        return "UNKNOWN";
      }
      return String(level).toUpperCase();
    },
    // Add a custom prettifier for error messages
    msg: (msg) => {
      return msg.replace(/ERROR \([^)]+\):/g, "ERROR:");
    }
  },
  messageFormat: "{msg}"
});
var createStream = async () => {
  if (raw) {
    return void 0;
  }
  const pretty = await import("pino-pretty");
  return pretty.default(createPrettyConfig());
};
var options = {
  level: effectiveLogLevel,
  // Use more restrictive level unless in debug mode
  customLevels,
  hooks: {
    logMethod(inputArgs, method) {
      const [arg1, ...rest] = inputArgs;
      const formatError = (err) => ({
        message: `(${err.name}) ${err.message}`,
        stack: err.stack?.split("\n").map((line) => line.trim())
      });
      if (typeof arg1 === "object") {
        if (arg1 instanceof Error) {
          method.apply(this, [
            {
              error: formatError(arg1)
            }
          ]);
        } else {
          const messageParts = rest.map(
            (arg) => typeof arg === "string" ? arg : JSON.stringify(arg)
          );
          const message = messageParts.join(" ");
          method.apply(this, [arg1, message]);
        }
      } else {
        const context = {};
        const messageParts = [arg1, ...rest].map((arg) => {
          if (arg instanceof Error) {
            return formatError(arg);
          }
          return typeof arg === "string" ? arg : arg;
        });
        const message = messageParts.filter((part) => typeof part === "string").join(" ");
        const jsonParts = messageParts.filter((part) => typeof part === "object");
        Object.assign(context, ...jsonParts);
        method.apply(this, [context, message]);
      }
    }
  }
};
var logger = pino(options);
if (typeof process !== "undefined") {
  let stream = null;
  if (!raw) {
    try {
      const pretty = __require("pino-pretty");
      stream = pretty.default ? pretty.default(createPrettyConfig()) : null;
    } catch (e) {
      createStream().then((prettyStream) => {
        const destination = new InMemoryDestination(prettyStream);
        logger = pino(options, destination);
        logger[Symbol.for("pino-destination")] = destination;
        logger.clear = () => {
          const destination2 = logger[Symbol.for("pino-destination")];
          if (destination2 instanceof InMemoryDestination) {
            destination2.clear();
          }
        };
      });
    }
  }
  if (stream !== null || raw) {
    const destination = new InMemoryDestination(stream);
    logger = pino(options, destination);
    logger[Symbol.for("pino-destination")] = destination;
    logger.clear = () => {
      const destination2 = logger[Symbol.for("pino-destination")];
      if (destination2 instanceof InMemoryDestination) {
        destination2.clear();
      }
    };
  }
}
var elizaLogger = logger;
var logger_default = logger;

// src/prompts.ts
var composePrompt = ({
  state,
  template
}) => {
  const templateStr = typeof template === "function" ? template({ state }) : template;
  const templateFunction = handlebars.compile(templateStr);
  const output = composeRandomUser(templateFunction(state), 10);
  return output;
};
var composePromptFromState = ({
  state,
  template
}) => {
  const templateStr = typeof template === "function" ? template({ state }) : template;
  const templateFunction = handlebars.compile(templateStr);
  const stateKeys = Object.keys(state);
  const filteredKeys = stateKeys.filter((key) => !["text", "values", "data"].includes(key));
  const filteredState = filteredKeys.reduce((acc, key) => {
    acc[key] = state[key];
    return acc;
  }, {});
  const output = composeRandomUser(templateFunction({ ...filteredState, ...state.values }), 10);
  return output;
};
var addHeader = (header, body) => {
  return body.length > 0 ? `${header ? `${header}
` : header}${body}
` : "";
};
var composeRandomUser = (template, length) => {
  const exampleNames = Array.from(
    { length },
    () => uniqueNamesGenerator2({ dictionaries: [names2] })
  );
  let result = template;
  for (let i = 0; i < exampleNames.length; i++) {
    result = result.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);
  }
  return result;
};
var formatPosts = ({
  messages,
  entities,
  conversationHeader = true
}) => {
  const groupedMessages = {};
  messages.forEach((message) => {
    if (message.roomId) {
      if (!groupedMessages[message.roomId]) {
        groupedMessages[message.roomId] = [];
      }
      groupedMessages[message.roomId].push(message);
    }
  });
  Object.values(groupedMessages).forEach((roomMessages) => {
    roomMessages.sort((a, b) => a.createdAt - b.createdAt);
  });
  const sortedRooms = Object.entries(groupedMessages).sort(
    ([, messagesA], [, messagesB]) => messagesB[messagesB.length - 1].createdAt - messagesA[messagesA.length - 1].createdAt
  );
  const formattedPosts = sortedRooms.map(([roomId, roomMessages]) => {
    const messageStrings = roomMessages.filter((message) => message.entityId).map((message) => {
      const entity = entities.find((entity2) => entity2.id === message.entityId);
      const userName = entity?.names[0] || "Unknown User";
      const displayName = entity?.names[0] || "unknown";
      return `Name: ${userName} (@${displayName})
ID: ${message.id}${message.content.inReplyTo ? `
In reply to: ${message.content.inReplyTo}` : ""}
Date: ${formatTimestamp(message.createdAt)}
Text:
${message.content.text}`;
    });
    const header = conversationHeader ? `Conversation: ${roomId.slice(-5)}
` : "";
    return `${header}${messageStrings.join("\n\n")}`;
  });
  return formattedPosts.join("\n\n");
};
var formatMessages = ({
  messages,
  entities
}) => {
  const messageStrings = messages.reverse().filter((message) => message.entityId).map((message) => {
    const messageText = message.content.text;
    const messageActions = message.content.actions;
    const messageThought = message.content.thought;
    const formattedName = entities.find((entity) => entity.id === message.entityId)?.names[0] || "Unknown User";
    const attachments = message.content.attachments;
    const attachmentString = attachments && attachments.length > 0 ? ` (Attachments: ${attachments.map((media) => `[${media.id} - ${media.title} (${media.url})]`).join(", ")})` : null;
    const messageTime = new Date(message.createdAt);
    const hours = messageTime.getHours().toString().padStart(2, "0");
    const minutes = messageTime.getMinutes().toString().padStart(2, "0");
    const timeString = `${hours}:${minutes}`;
    const timestamp = formatTimestamp(message.createdAt);
    const thoughtString = messageThought ? `(${formattedName}'s internal thought: ${messageThought})` : null;
    const timestampString = `${timeString} (${timestamp}) [${message.entityId}]`;
    const textString = messageText ? `${timestampString} ${formattedName}: ${messageText}` : null;
    const actionString = messageActions && messageActions.length > 0 ? `${textString ? "" : timestampString} (${formattedName}'s actions: ${messageActions.join(", ")})` : null;
    const messageString = [textString, thoughtString, actionString, attachmentString].filter(Boolean).join("\n");
    return messageString;
  }).join("\n");
  return messageStrings;
};
var formatTimestamp = (messageDate) => {
  const now = /* @__PURE__ */ new Date();
  const diff = now.getTime() - messageDate;
  const absDiff = Math.abs(diff);
  const seconds = Math.floor(absDiff / 1e3);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (absDiff < 6e4) {
    return "just now";
  }
  if (minutes < 60) {
    return `${minutes} minute${minutes !== 1 ? "s" : ""} ago`;
  }
  if (hours < 24) {
    return `${hours} hour${hours !== 1 ? "s" : ""} ago`;
  }
  return `${days} day${days !== 1 ? "s" : ""} ago`;
};
var jsonBlockPattern = /```json\n([\s\S]*?)\n```/;
var shouldRespondTemplate = `# Task: Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.
{{providers}}
# Instructions: Decide if {{agentName}} should respond to or interact with the conversation.
If the message is directed at or relevant to {{agentName}}, respond with RESPOND action.
If a user asks {{agentName}} to be quiet, respond with STOP action.
If {{agentName}} should ignore the message, respond with IGNORE action.
If responding with the RESPOND action, include a list of optional providers that could be relevant to the response.
Response format should be formatted in a valid JSON block like this:
\`\`\`json
{
    "name": "{{agentName}}",
	"reasoning": "<string>",
    "action": "RESPOND" | "IGNORE" | "STOP",
    "providers": ["<string>", "<string>", ...]
}
\`\`\`
Your response should include the valid JSON block and nothing else.`;
var messageHandlerTemplate = `# Task: Generate dialog and actions for the character {{agentName}}.
{{providers}}
# Instructions: Write a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.
First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
"thought" should be a short description of what the agent is thinking about and planning.
"actions" should be an array of the actions {{agentName}} plans to take based on the thought (if none, use IGNORE, if simply responding with text, use REPLY)
"providers" should be an optional array of the providers that {{agentName}} will use to have the right context for responding and acting
"evaluators" should be an optional array of the evaluators that {{agentName}} will use to evaluate the conversation after responding
These are the available valid actions: {{actionNames}}

Response format should be formatted in a valid JSON block like this:
\`\`\`json
{
    "thought": "<string>",
    "actions": ["<string>", "<string>", ...],
    "providers": ["<string>", "<string>", ...]
}
\`\`\`

Your response should include the valid JSON block and nothing else.`;
var postCreationTemplate = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.

Example task outputs:
1. A post about the importance of AI in our lives
\`\`\`json
{ "thought": "I am thinking about writing a post about the importance of AI in our lives", "post": "AI is changing the world and it is important to understand how it works", "imagePrompt": "A futuristic cityscape with flying cars and people using AI to do things" }
\`\`\`

2. A post about dogs
\`\`\`json
{ "thought": "I am thinking about writing a post about dogs", "post": "Dogs are man's best friend and they are loyal and loving", "imagePrompt": "A dog playing with a ball in a park" }
\`\`\`

3. A post about finding a new job
\`\`\`json
{ "thought": "Getting a job is hard, I bet there's a good tweet in that", "post": "Just keep going!", "imagePrompt": "A person looking at a computer screen with a job search website" }
\`\`\`

{{providers}}

Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.

Your output should be formatted in a valid JSON block like this:
\`\`\`json
{ "thought": "<string>", "post": "<string>", "imagePrompt": "<string>" }
\`\`\`
The "post" field should be the post you want to send. Do not including any thinking or internal reflection in the "post" field.
The "imagePrompt" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.
The "thought" field should be a short description of what the agent is thinking about before responding, inlcuding a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.
Your reponse should ONLY contain a valid JSON block and nothing else.`;
var booleanFooter = "Respond with only a YES or a NO.";
function parseBooleanFromText2(value) {
  if (!value) return false;
  const affirmative = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"];
  const negative = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"];
  const normalizedText = value.trim().toUpperCase();
  if (affirmative.includes(normalizedText)) {
    return true;
  }
  if (negative.includes(normalizedText)) {
    return false;
  }
  return false;
}
var stringArrayFooter = `Respond with a JSON array containing the values in a valid JSON block formatted for markdown with this structure:
\`\`\`json
[
  'value',
  'value'
]
\`\`\`

Your response must include the valid JSON block.`;
function parseJsonArrayFromText(text) {
  let jsonData = null;
  const jsonBlockMatch = text?.match(jsonBlockPattern);
  if (jsonBlockMatch) {
    try {
      const normalizedJson = jsonBlockMatch[1].replace(/(?<!\\)'([^']*)'(?=\s*[,}\]])/g, '"$1"');
      jsonData = JSON.parse(normalizeJsonString(normalizedJson));
    } catch (_e) {
      logger_default.warn("Could not parse text as JSON, will try pattern matching");
    }
  }
  if (!jsonData) {
    const arrayPattern = /\[\s*(['"])(.*?)\1\s*\]/;
    const arrayMatch = text.match(arrayPattern);
    if (arrayMatch) {
      try {
        const normalizedJson = arrayMatch[0].replace(/(?<!\\)'([^']*)'(?=\s*[,}\]])/g, '"$1"');
        jsonData = JSON.parse(normalizeJsonString(normalizedJson));
      } catch (_e) {
        logger_default.warn("Could not parse text as JSON, returning null");
      }
    }
  }
  if (Array.isArray(jsonData)) {
    return jsonData;
  }
  return null;
}
function parseJSONObjectFromText(text) {
  let jsonData = null;
  const jsonBlockMatch = text.match(jsonBlockPattern);
  try {
    if (jsonBlockMatch) {
      jsonData = JSON.parse(normalizeJsonString(jsonBlockMatch[1].trim()));
    } else {
      jsonData = JSON.parse(normalizeJsonString(text.trim()));
    }
  } catch (_e) {
    logger_default.warn("Could not parse text as JSON, returning null");
    return null;
  }
  if (jsonData && typeof jsonData === "object" && !Array.isArray(jsonData)) {
    return jsonData;
  }
  logger_default.warn("Could not parse text as JSON, returning null");
  return null;
}
function extractAttributes(response, attributesToExtract) {
  const attributes = {};
  if (!attributesToExtract || attributesToExtract.length === 0) {
    const matches = response.matchAll(/"([^"]+)"\s*:\s*"([^"]*)"/g);
    for (const match of matches) {
      attributes[match[1]] = match[2];
    }
  } else {
    for (const attribute of attributesToExtract) {
      const match = response.match(new RegExp(`"${attribute}"\\s*:\\s*"([^"]*)"`, "i"));
      if (match) {
        attributes[attribute] = match[1];
      }
    }
  }
  return attributes;
}
var normalizeJsonString = (str) => {
  str = str.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim();
  str = str.replace(/("[\w\d_-]+")\s*: \s*(?!"|\[)([\s\S]+?)(?=(,\s*"|\}$))/g, '$1: "$2"');
  str = str.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (_, key, value) => `"${key}": "${value}"`);
  str = str.replace(/("[\w\d_-]+")\s*:\s*([A-Za-z_]+)(?!["\w])/g, '$1: "$2"');
  str = str.replace(/(?:"')|(?:'")/g, '"');
  return str;
};
function cleanJsonResponse(response) {
  return response.replace(/```json\s*/g, "").replace(/```\s*/g, "").replace(/(\r\n|\n|\r)/g, "").trim();
}
var postActionResponseFooter = "Choose any combination of [LIKE], [RETWEET], [QUOTE], and [REPLY] that are appropriate. Each action must be on its own line. Your response must only include the chosen actions.";
var parseActionResponseFromText = (text) => {
  const actions = {
    like: false,
    retweet: false,
    quote: false,
    reply: false
  };
  const likePattern = /\[LIKE\]/i;
  const retweetPattern = /\[RETWEET\]/i;
  const quotePattern = /\[QUOTE\]/i;
  const replyPattern = /\[REPLY\]/i;
  actions.like = likePattern.test(text);
  actions.retweet = retweetPattern.test(text);
  actions.quote = quotePattern.test(text);
  actions.reply = replyPattern.test(text);
  const lines = text.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === "[LIKE]") actions.like = true;
    if (trimmed === "[RETWEET]") actions.retweet = true;
    if (trimmed === "[QUOTE]") actions.quote = true;
    if (trimmed === "[REPLY]") actions.reply = true;
  }
  return { actions };
};
function truncateToCompleteSentence(text, maxLength) {
  if (text.length <= maxLength) {
    return text;
  }
  const lastPeriodIndex = text.lastIndexOf(".", maxLength - 1);
  if (lastPeriodIndex !== -1) {
    const truncatedAtPeriod = text.slice(0, lastPeriodIndex + 1).trim();
    if (truncatedAtPeriod.length > 0) {
      return truncatedAtPeriod;
    }
  }
  const lastSpaceIndex = text.lastIndexOf(" ", maxLength - 1);
  if (lastSpaceIndex !== -1) {
    const truncatedAtSpace = text.slice(0, lastSpaceIndex).trim();
    if (truncatedAtSpace.length > 0) {
      return `${truncatedAtSpace}...`;
    }
  }
  const hardTruncated = text.slice(0, maxLength - 3).trim();
  return `${hardTruncated}...`;
}
var TOKENS_PER_CHAR = 4;
var TARGET_TOKENS = 3e3;
var _TARGET_CHARS = Math.floor(TARGET_TOKENS / TOKENS_PER_CHAR);
async function splitChunks(content, chunkSize = 512, bleed = 20) {
  logger_default.debug("[splitChunks] Starting text split");
  const textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: Number(chunkSize),
    chunkOverlap: Number(bleed)
  });
  const chunks = await textSplitter.splitText(content);
  logger_default.debug("[splitChunks] Split complete:", {
    numberOfChunks: chunks.length,
    averageChunkSize: chunks.reduce((acc, chunk) => acc + chunk.length, 0) / chunks.length
  });
  return chunks;
}
async function trimTokens(prompt, maxTokens, runtime) {
  if (!prompt) throw new Error("Trim tokens received a null prompt");
  if (prompt.length < maxTokens / 5) return prompt;
  if (maxTokens <= 0) throw new Error("maxTokens must be positive");
  try {
    const tokens = await runtime.useModel(ModelType.TEXT_TOKENIZER_ENCODE, {
      prompt
    });
    if (tokens.length <= maxTokens) {
      return prompt;
    }
    const truncatedTokens = tokens.slice(-maxTokens);
    return await runtime.useModel(ModelType.TEXT_TOKENIZER_DECODE, {
      tokens: truncatedTokens
    });
  } catch (error) {
    logger_default.error("Error in trimTokens:", error);
    return prompt.slice(-maxTokens * 4);
  }
}

// src/entities.ts
var entityResolutionTemplate = `# Task: Resolve Entity Name
Message Sender: {{senderName}} (ID: {{senderId}})
Agent: {{agentName}} (ID: {{agentId}})

# Entities in Room:
{{#if entitiesInRoom}}
{{entitiesInRoom}}
{{/if}}

{{recentMessages}}

# Instructions:
1. Analyze the context to identify which entity is being referenced
2. Consider special references like "me" (the message sender) or "you" (agent the message is directed to)
3. Look for usernames/handles in standard formats (e.g. @username, user#1234)
4. Consider context from recent messages for pronouns and references
5. If multiple matches exist, use context to disambiguate
6. Consider recent interactions and relationship strength when resolving ambiguity

Return a JSON object with:
\`\`\`json
{
  "entityId": "exact-id-if-known-otherwise-null",
  "type": "EXACT_MATCH | USERNAME_MATCH | NAME_MATCH | RELATIONSHIP_MATCH | AMBIGUOUS | UNKNOWN",
  "matches": [{
    "name": "matched-name",
    "reason": "why this entity matches"
  }]
}
\`\`\`

Make sure to include the \`\`\`json\`\`\` tags around the JSON object.
`;
async function getRecentInteractions(runtime, sourceEntityId, candidateEntities, roomId, relationships) {
  const results = [];
  const recentMessages = await runtime.getMemories({
    tableName: "messages",
    roomId,
    count: 20
    // Reduced from 100 since we only need context
  });
  for (const entity of candidateEntities) {
    const interactions = [];
    let interactionScore = 0;
    const directReplies = recentMessages.filter(
      (msg) => msg.entityId === sourceEntityId && msg.content.inReplyTo === entity.id || msg.entityId === entity.id && msg.content.inReplyTo === sourceEntityId
    );
    interactions.push(...directReplies);
    const relationship = relationships.find(
      (rel) => rel.sourceEntityId === sourceEntityId && rel.targetEntityId === entity.id || rel.targetEntityId === sourceEntityId && rel.sourceEntityId === entity.id
    );
    if (relationship?.metadata?.interactions) {
      interactionScore = relationship.metadata.interactions;
    }
    interactionScore += directReplies.length;
    const uniqueInteractions = [...new Set(interactions)];
    results.push({
      entity,
      interactions: uniqueInteractions.slice(-5),
      // Only keep last 5 messages for context
      count: Math.round(interactionScore)
    });
  }
  return results.sort((a, b) => b.count - a.count);
}
async function findEntityByName(runtime, message, state) {
  try {
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    if (!room) {
      logger.warn("Room not found for entity search");
      return null;
    }
    const world = room.worldId ? await runtime.getWorld(room.worldId) : null;
    const entitiesInRoom = await runtime.getEntitiesForRoom(room.id, true);
    const filteredEntities = await Promise.all(
      entitiesInRoom.map(async (entity) => {
        if (!entity.components) return entity;
        const worldRoles = world?.metadata?.roles || {};
        entity.components = entity.components.filter((component) => {
          if (component.sourceEntityId === message.entityId) return true;
          if (world && component.sourceEntityId) {
            const sourceRole = worldRoles[component.sourceEntityId];
            if (sourceRole === "OWNER" || sourceRole === "ADMIN") return true;
          }
          if (component.sourceEntityId === runtime.agentId) return true;
          return false;
        });
        return entity;
      })
    );
    const relationships = await runtime.getRelationships({
      entityId: message.entityId
    });
    const relationshipEntities = await Promise.all(
      relationships.map(async (rel) => {
        const entityId = rel.sourceEntityId === message.entityId ? rel.targetEntityId : rel.sourceEntityId;
        return runtime.getEntityById(entityId);
      })
    );
    const allEntities = [
      ...filteredEntities,
      ...relationshipEntities.filter((e) => e !== null)
    ];
    const interactionData = await getRecentInteractions(
      runtime,
      message.entityId,
      allEntities,
      room.id,
      relationships
    );
    const prompt = composePrompt({
      state: {
        roomName: room.name || room.id,
        worldName: world?.name || "Unknown",
        entitiesInRoom: JSON.stringify(filteredEntities, null, 2),
        entityId: message.entityId,
        senderId: message.entityId
      },
      template: entityResolutionTemplate
    });
    const result = await runtime.useModel(ModelType.TEXT_SMALL, {
      prompt,
      stopSequences: []
    });
    const resolution = parseJSONObjectFromText(result);
    if (!resolution) {
      logger.warn("Failed to parse entity resolution result");
      return null;
    }
    if (resolution.type === "EXACT_MATCH" && resolution.entityId) {
      const entity = await runtime.getEntityById(resolution.entityId);
      if (entity) {
        if (entity.components) {
          const worldRoles = world?.metadata?.roles || {};
          entity.components = entity.components.filter((component) => {
            if (component.sourceEntityId === message.entityId) return true;
            if (world && component.sourceEntityId) {
              const sourceRole = worldRoles[component.sourceEntityId];
              if (sourceRole === "OWNER" || sourceRole === "ADMIN") return true;
            }
            if (component.sourceEntityId === runtime.agentId) return true;
            return false;
          });
        }
        return entity;
      }
    }
    if (resolution.matches?.[0]?.name) {
      const matchName = resolution.matches[0].name.toLowerCase();
      const matchingEntity = allEntities.find((entity) => {
        if (entity.names.some((n) => n.toLowerCase() === matchName)) return true;
        return entity.components?.some(
          (c) => c.data.username?.toLowerCase() === matchName || c.data.handle?.toLowerCase() === matchName
        );
      });
      if (matchingEntity) {
        if (resolution.type === "RELATIONSHIP_MATCH") {
          const interactionInfo = interactionData.find((d) => d.entity.id === matchingEntity.id);
          if (interactionInfo && interactionInfo.count > 0) {
            return matchingEntity;
          }
        } else {
          return matchingEntity;
        }
      }
    }
    return null;
  } catch (error) {
    logger.error("Error in findEntityByName:", error);
    return null;
  }
}
var createUniqueUuid = (runtime, baseUserId) => {
  if (baseUserId === runtime.agentId) {
    return runtime.agentId;
  }
  const combinedString = `${baseUserId}:${runtime.agentId}`;
  return stringToUuid(combinedString);
};
async function getEntityDetails({
  runtime,
  roomId
}) {
  const [room, roomEntities] = await Promise.all([
    runtime.getRoom(roomId),
    runtime.getEntitiesForRoom(roomId, true)
  ]);
  const uniqueEntities = /* @__PURE__ */ new Map();
  for (const entity of roomEntities) {
    if (uniqueEntities.has(entity.id)) continue;
    const allData = {};
    for (const component of entity.components || []) {
      Object.assign(allData, component.data);
    }
    const mergedData = {};
    for (const [key, value] of Object.entries(allData)) {
      if (!mergedData[key]) {
        mergedData[key] = value;
        continue;
      }
      if (Array.isArray(mergedData[key]) && Array.isArray(value)) {
        mergedData[key] = [.../* @__PURE__ */ new Set([...mergedData[key], ...value])];
      } else if (typeof mergedData[key] === "object" && typeof value === "object") {
        mergedData[key] = { ...mergedData[key], ...value };
      }
    }
    uniqueEntities.set(entity.id, {
      id: entity.id,
      name: entity.metadata[room.source]?.name || entity.names[0],
      names: entity.names,
      data: JSON.stringify({ ...mergedData, ...entity.metadata })
    });
  }
  return Array.from(uniqueEntities.values());
}
function formatEntities({ entities }) {
  const entityStrings = entities.map((entity) => {
    const header = `${entity.names.join(" aka ")}
ID: ${entity.id}${entity.metadata && Object.keys(entity.metadata).length > 0 ? `
Data: ${JSON.stringify(entity.metadata)}
` : "\n"}`;
    return header;
  });
  return entityStrings.join("\n");
}

// src/import.ts
var registrations = /* @__PURE__ */ new Map();
var dynamicImport = async (specifier) => {
  const module = registrations.get(specifier);
  if (module !== void 0) {
    return module;
  }
  return await import(specifier);
};
var registerDynamicImport = (specifier, module) => {
  registrations.set(specifier, module);
};
function getVersionTag() {
  let versionTag = "@latest";
  try {
    const { version: coreVersion } = require_package();
    if (coreVersion.includes("beta")) {
      versionTag = "@beta";
    } else if (coreVersion.includes("alpha")) {
      versionTag = "@alpha";
    }
  } catch (error) {
    logger_default.warn(`Could not determine core version, using @latest tag: ${error}`);
  }
  return versionTag;
}
async function handlePluginImporting(plugins) {
  if (plugins.length > 0) {
    const versionTag = getVersionTag();
    const importedPlugins = await Promise.all(
      plugins.map(async (plugin) => {
        try {
          const pluginWithTag = plugin.includes("@") && plugin.split("@").length > 2 ? plugin : `${plugin}${versionTag}`;
          const importedPlugin = await import(pluginWithTag);
          const functionName = `${plugin.replace("@elizaos/plugin-", "").replace("@elizaos-plugins/", "").replace(/-./g, (x) => x[1].toUpperCase())}Plugin`;
          if (functionName === "localAiPlugin") {
            return importedPlugin["localAIPlugin"];
          }
          return importedPlugin.default || importedPlugin[functionName];
        } catch (importError) {
          logger_default.error(
            `Failed to import plugin: ${plugin} during runtime dynamic import`,
            `coreVersion: ${versionTag}`
          );
          return [];
        }
      })
    );
    return importedPlugins;
  }
  return [];
}

// src/roles.ts
async function getUserServerRole(runtime, entityId, serverId) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world || !world.metadata?.roles) {
      return "NONE" /* NONE */;
    }
    if (world.metadata.roles[entityId]) {
      return world.metadata.roles[entityId];
    }
    if (world.metadata.roles[entityId]) {
      return world.metadata.roles[entityId];
    }
    return "NONE" /* NONE */;
  } catch (error) {
    logger.error(`Error getting user role: ${error}`);
    return "NONE" /* NONE */;
  }
}
async function findWorldsForOwner(runtime, entityId) {
  try {
    if (!entityId) {
      logger.error("User ID is required to find server");
      return null;
    }
    const worlds = await runtime.getAllWorlds();
    if (!worlds || worlds.length === 0) {
      logger.info("No worlds found for this agent");
      return null;
    }
    const ownerWorlds = [];
    for (const world of worlds) {
      if (world.metadata?.ownership?.ownerId === entityId) {
        ownerWorlds.push(world);
      }
    }
    return ownerWorlds.length ? ownerWorlds : null;
  } catch (error) {
    logger.error(`Error finding server for owner: ${error}`);
    return null;
  }
}

// src/runtime.ts
import { v4 as uuidv4 } from "uuid";

// src/uuid.ts
import { sha1 } from "js-sha1";
import { z } from "zod";
var uuidSchema = z.string().uuid();
function validateUuid(value) {
  const result = uuidSchema.safeParse(value);
  return result.success ? result.data : null;
}
function stringToUuid(target) {
  if (typeof target === "number") {
    target = target.toString();
  }
  if (typeof target !== "string") {
    throw TypeError("Value must be string");
  }
  const _uint8ToHex = (ubyte) => {
    const first = ubyte >> 4;
    const second = ubyte - (first << 4);
    const HEX_DIGITS = "0123456789abcdef".split("");
    return HEX_DIGITS[first] + HEX_DIGITS[second];
  };
  const _uint8ArrayToHex = (buf) => {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += _uint8ToHex(buf[i]);
    }
    return out;
  };
  const escapedStr = encodeURIComponent(target);
  const buffer = new Uint8Array(escapedStr.length);
  for (let i = 0; i < escapedStr.length; i++) {
    buffer[i] = escapedStr[i].charCodeAt(0);
  }
  const hash = sha1(buffer);
  const hashBuffer = new Uint8Array(hash.length / 2);
  for (let i = 0; i < hash.length; i += 2) {
    hashBuffer[i / 2] = Number.parseInt(hash.slice(i, i + 2), 16);
  }
  return `${_uint8ArrayToHex(hashBuffer.slice(0, 4))}-${_uint8ArrayToHex(hashBuffer.slice(4, 6))}-${_uint8ToHex(hashBuffer[6] & 15)}${_uint8ToHex(hashBuffer[7])}-${_uint8ToHex(hashBuffer[8] & 63 | 128)}${_uint8ToHex(hashBuffer[9])}-${_uint8ArrayToHex(hashBuffer.slice(10, 16))}`;
}

// src/runtime.ts
var environmentSettings = {};
var Semaphore = class {
  permits;
  waiting = [];
  constructor(count) {
    this.permits = count;
  }
  async acquire() {
    if (this.permits > 0) {
      this.permits -= 1;
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.waiting.push(resolve);
    });
  }
  release() {
    this.permits += 1;
    const nextResolve = this.waiting.shift();
    if (nextResolve && this.permits > 0) {
      this.permits -= 1;
      nextResolve();
    }
  }
};
var AgentRuntime = class {
  #conversationLength = 32;
  agentId;
  character;
  adapter;
  actions = [];
  evaluators = [];
  providers = [];
  plugins = [];
  events = /* @__PURE__ */ new Map();
  stateCache = /* @__PURE__ */ new Map();
  fetch = fetch;
  services = /* @__PURE__ */ new Map();
  models = /* @__PURE__ */ new Map();
  routes = [];
  taskWorkers = /* @__PURE__ */ new Map();
  // Event emitter methods
  eventHandlers = /* @__PURE__ */ new Map();
  runtimeLogger;
  knowledgeProcessingSemaphore = new Semaphore(10);
  settings;
  servicesInitQueue = /* @__PURE__ */ new Set();
  constructor(opts) {
    this.agentId = opts.character?.id ?? opts?.agentId ?? stringToUuid(opts.character?.name ?? uuidv4());
    this.character = opts.character;
    const logLevel = process.env.LOG_LEVEL || "info";
    this.runtimeLogger = logger_default.child({
      agentName: this.character?.name,
      agentId: this.agentId,
      level: logLevel === "debug" ? "debug" : "error"
      // Show only errors unless debug mode is enabled
    });
    this.runtimeLogger.debug(`[AgentRuntime] Process working directory: ${process.cwd()}`);
    this.#conversationLength = opts.conversationLength ?? this.#conversationLength;
    if (opts.adapter) {
      this.registerDatabaseAdapter(opts.adapter);
    }
    this.fetch = opts.fetch ?? this.fetch;
    this.settings = opts.settings ?? environmentSettings;
    const plugins = opts?.plugins ?? [];
    this.plugins = plugins;
    this.runtimeLogger.debug(`Success: Agent ID: ${this.agentId}`);
  }
  /**
   * Registers a plugin with the runtime and initializes its components
   * @param plugin The plugin to register
   */
  async registerPlugin(plugin) {
    if (!plugin) {
      this.runtimeLogger.error("*** registerPlugin plugin is undefined");
      throw new Error("*** registerPlugin plugin is undefined");
    }
    if (!this.plugins.some((p) => p.name === plugin.name)) {
      this.plugins.push(plugin);
      this.runtimeLogger.debug(`Success: Plugin ${plugin.name} registered successfully`);
    }
    if (plugin.init) {
      try {
        await plugin.init(plugin.config || {}, this);
        this.runtimeLogger.debug(`Success: Plugin ${plugin.name} initialized successfully`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes("API key") || errorMessage.includes("environment variables") || errorMessage.includes("Invalid plugin configuration")) {
          console.warn(`Plugin ${plugin.name} requires configuration. ${errorMessage}`);
          console.warn(
            "Please check your environment variables and ensure all required API keys are set."
          );
          console.warn("You can set these in your .eliza/.env file.");
        } else {
          throw error;
        }
      }
    }
    if (plugin.adapter) {
      this.runtimeLogger.debug(`Registering database adapter for plugin ${plugin.name}`);
      this.registerDatabaseAdapter(plugin.adapter);
    }
    if (plugin.actions) {
      for (const action of plugin.actions) {
        this.registerAction(action);
      }
    }
    if (plugin.evaluators) {
      for (const evaluator of plugin.evaluators) {
        this.registerEvaluator(evaluator);
      }
    }
    if (plugin.providers) {
      for (const provider of plugin.providers) {
        this.registerContextProvider(provider);
      }
    }
    if (plugin.models) {
      for (const [modelType, handler] of Object.entries(plugin.models)) {
        this.registerModel(modelType, handler);
      }
    }
    if (plugin.routes) {
      for (const route of plugin.routes) {
        this.routes.push(route);
      }
    }
    if (plugin.events) {
      for (const [eventName, eventHandlers] of Object.entries(plugin.events)) {
        for (const eventHandler of eventHandlers) {
          this.registerEvent(eventName, eventHandler);
        }
      }
    }
    if (plugin.services) {
      plugin.services.forEach((service) => {
        this.servicesInitQueue.add(service);
      });
    }
  }
  getAllServices() {
    return this.services;
  }
  async stop() {
    this.runtimeLogger.debug(`runtime::stop - character ${this.character.name}`);
    for (const [serviceName, service] of this.services) {
      this.runtimeLogger.debug(`runtime::stop - requesting service stop for ${serviceName}`);
      await service.stop();
    }
  }
  async initialize() {
    const registeredPluginNames = /* @__PURE__ */ new Set();
    const pluginRegistrationPromises = [];
    if (this.character.plugins) {
      const characterPlugins = await handlePluginImporting(this.character.plugins);
      for (const plugin of characterPlugins) {
        if (plugin && !registeredPluginNames.has(plugin.name)) {
          registeredPluginNames.add(plugin.name);
          pluginRegistrationPromises.push(await this.registerPlugin(plugin));
        }
      }
    }
    for (const plugin of [...this.plugins]) {
      if (plugin && !registeredPluginNames.has(plugin.name)) {
        registeredPluginNames.add(plugin.name);
        pluginRegistrationPromises.push(await this.registerPlugin(plugin));
      }
    }
    await this.adapter.init();
    try {
      const agentExists = await this.adapter.ensureAgentExists(this.character);
      const agent = await this.adapter.getAgent(this.agentId);
      if (!agent) {
        throw new Error(
          `Agent ${this.agentId} does not exist in database after ensureAgentExists call`
        );
      }
      const agentEntity = await this.adapter.getEntityById(this.agentId);
      if (!agentEntity) {
        const created = await this.createEntity({
          id: this.agentId,
          agentId: this.agentId,
          names: Array.from(new Set([this.character.name].filter(Boolean))),
          metadata: {}
        });
        if (!created) {
          throw new Error(`Failed to create entity for agent ${this.agentId}`);
        }
        this.runtimeLogger.debug(
          `Success: Agent entity created successfully for ${this.character.name}`
        );
      }
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to create agent entity: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
    try {
      await Promise.all([
        this.ensureRoomExists({
          id: this.agentId,
          name: this.character.name,
          source: "self",
          type: "SELF" /* SELF */
        }),
        ...pluginRegistrationPromises
      ]);
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to initialize: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
    try {
      const participants = await this.adapter.getParticipantsForRoom(this.agentId);
      if (!participants.includes(this.agentId)) {
        const added = await this.adapter.addParticipant(this.agentId, this.agentId);
        if (!added) {
          throw new Error(`Failed to add agent ${this.agentId} as participant to its own room`);
        }
        this.runtimeLogger.debug(
          `Agent ${this.character.name} linked to its own room successfully`
        );
      }
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to add agent as participant: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
    const embeddingModel = this.getModel(ModelType.TEXT_EMBEDDING);
    if (!embeddingModel) {
      this.runtimeLogger.warn(
        `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered. Skipping embedding dimension setup.`
      );
    } else {
      await this.ensureEmbeddingDimension();
    }
    if (this.character?.knowledge && this.character.knowledge.length > 0) {
      const stringKnowledge = this.character.knowledge.filter(
        (item) => typeof item === "string"
      );
      await this.processCharacterKnowledge(stringKnowledge);
    }
    for (const service of this.servicesInitQueue) {
      await this.registerService(service);
    }
  }
  async handleProcessingError(error, context) {
    this.runtimeLogger.error(`Error ${context}:`, error?.message || error || "Unknown error");
    throw error;
  }
  async checkExistingKnowledge(knowledgeId) {
    const existingDocument = await this.getMemoryById(knowledgeId);
    return !!existingDocument;
  }
  async getKnowledge(message) {
    if (!message?.content?.text) {
      this.runtimeLogger.warn("Invalid message for knowledge query:", {
        message,
        content: message?.content,
        text: message?.content?.text
      });
      return [];
    }
    if (!message?.content?.text || message?.content?.text.trim().length === 0) {
      this.runtimeLogger.warn("Empty text for knowledge query");
      return [];
    }
    const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, {
      text: message?.content?.text
    });
    const fragments = await this.searchMemories({
      tableName: "knowledge",
      embedding,
      roomId: message.agentId,
      count: 5,
      match_threshold: 0.1
    });
    const uniqueSources = [
      ...new Set(
        fragments.map((memory) => {
          this.runtimeLogger.debug(
            `Matched fragment: ${memory.content.text} with similarity: ${memory.similarity}`
          );
          return memory?.metadata?.type === "fragment" /* FRAGMENT */ ? memory?.metadata?.documentId : void 0;
        }).filter(Boolean)
      )
    ];
    const knowledgeDocuments = await Promise.all(
      uniqueSources.map((source) => this.getMemoryById(source))
    );
    return knowledgeDocuments.filter((memory) => memory !== null).map((memory) => ({ id: memory.id, content: memory.content }));
  }
  async addKnowledge(item, options2 = {
    targetTokens: 3e3,
    overlap: 200,
    modelContextSize: 4096
  }) {
    const documentMemory = {
      id: item.id,
      agentId: this.agentId,
      roomId: this.agentId,
      entityId: this.agentId,
      content: item.content,
      metadata: item.metadata || {
        type: "document" /* DOCUMENT */,
        timestamp: Date.now()
      }
    };
    await this.createMemory(documentMemory, "documents");
    const fragments = await splitChunks(item.content.text, options2.targetTokens, options2.overlap);
    for (let i = 0; i < fragments.length; i++) {
      const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, fragments[i]);
      const fragmentMemory = {
        id: createUniqueUuid(this, `${item.id}-fragment-${i}`),
        agentId: this.agentId,
        roomId: this.agentId,
        entityId: this.agentId,
        embedding,
        content: { text: fragments[i] },
        metadata: {
          type: "fragment" /* FRAGMENT */,
          documentId: item.id,
          // Link to source document
          position: i,
          // Keep track of order
          timestamp: Date.now()
        }
      };
      await this.createMemory(fragmentMemory, "knowledge");
    }
  }
  async processCharacterKnowledge(items) {
    const processingPromises = items.map(async (item) => {
      await this.knowledgeProcessingSemaphore.acquire();
      try {
        const knowledgeId = createUniqueUuid(this, item);
        if (await this.checkExistingKnowledge(knowledgeId)) {
          return;
        }
        this.runtimeLogger.debug(
          "Processing knowledge for ",
          this.character.name,
          " - ",
          item.slice(0, 100)
        );
        let metadata = {
          type: "document" /* DOCUMENT */,
          timestamp: Date.now()
        };
        const pathMatch = item.match(/^Path: (.+?)(?:\n|\r\n)/);
        if (pathMatch) {
          const filePath = pathMatch[1].trim();
          const extension = filePath.split(".").pop() || "";
          const filename = filePath.split("/").pop() || "";
          const title = filename.replace(`.${extension}`, "");
          metadata = {
            ...metadata,
            path: filePath,
            filename,
            fileExt: extension,
            title,
            fileType: `text/${extension || "plain"}`,
            fileSize: item.length,
            source: "character"
          };
        }
        await this.addKnowledge({
          id: knowledgeId,
          content: {
            text: item
          },
          metadata
        });
      } catch (error) {
        await this.handleProcessingError(error, "processing character knowledge");
      } finally {
        this.knowledgeProcessingSemaphore.release();
      }
    });
    await Promise.all(processingPromises);
  }
  setSetting(key, value, secret = false) {
    if (secret) {
      if (!this.character.secrets) {
        this.character.secrets = {};
      }
      this.character.secrets[key] = value;
    } else {
      if (!this.character.settings) {
        this.character.settings = {};
      }
      this.character.settings[key] = value;
    }
  }
  getSetting(key) {
    const value = this.character.secrets?.[key] || this.character.settings?.[key] || this.character.settings?.secrets?.[key] || this.settings[key];
    const decryptedValue = decryptStringValue(value, getSalt());
    if (decryptedValue === "true") return true;
    if (decryptedValue === "false") return false;
    return decryptedValue || null;
  }
  /**
   * Get the number of messages that are kept in the conversation buffer.
   * @returns The number of recent messages to be kept in memory.
   */
  getConversationLength() {
    return this.#conversationLength;
  }
  registerDatabaseAdapter(adapter) {
    if (this.adapter) {
      this.runtimeLogger.warn(
        "Database adapter already registered. Additional adapters will be ignored. This may lead to unexpected behavior."
      );
    } else {
      this.adapter = adapter;
      this.runtimeLogger.debug("Success: Database adapter registered successfully.");
    }
  }
  /**
   * Register a provider for the agent to use.
   * @param provider The provider to register.
   */
  registerProvider(provider) {
    this.providers.push(provider);
    this.runtimeLogger.debug(`Success: Provider ${provider.name} registered successfully.`);
  }
  /**
   * Register an action for the agent to perform.
   * @param action The action to register.
   */
  registerAction(action) {
    this.runtimeLogger.debug(
      `${this.character.name}(${this.agentId}) - Registering action: ${action.name}`
    );
    if (this.actions.find((a) => a.name === action.name)) {
      this.runtimeLogger.warn(
        `${this.character.name}(${this.agentId}) - Action ${action.name} already exists. Skipping registration.`
      );
    } else {
      this.actions.push(action);
      this.runtimeLogger.debug(
        `${this.character.name}(${this.agentId}) - Action ${action.name} registered successfully.`
      );
    }
  }
  /**
   * Register an evaluator to assess and guide the agent's responses.
   * @param evaluator The evaluator to register.
   */
  registerEvaluator(evaluator) {
    this.evaluators.push(evaluator);
  }
  /**
   * Register a context provider to provide context for message generation.
   * @param provider The context provider to register.
   */
  registerContextProvider(provider) {
    this.providers.push(provider);
  }
  /**
   * Process the actions of a message.
   * @param message The message to process.
   * @param responses The array of response memories to process actions from.
   * @param state Optional state object for the action processing.
   * @param callback Optional callback handler for action results.
   */
  async processActions(message, responses, state, callback) {
    for (const response of responses) {
      let normalizeAction = function(action) {
        return action.toLowerCase().replace("_", "");
      };
      if (!response.content?.actions || response.content.actions.length === 0) {
        this.runtimeLogger.warn("No action found in the response content.");
        continue;
      }
      const actions = response.content.actions;
      this.runtimeLogger.debug(
        `Found actions: ${this.actions.map((a) => normalizeAction(a.name))}`
      );
      for (const responseAction of actions) {
        state = await this.composeState(message, ["RECENT_MESSAGES"]);
        this.runtimeLogger.debug(`Success: Calling action: ${responseAction}`);
        const normalizedResponseAction = normalizeAction(responseAction);
        let action = this.actions.find(
          (a) => normalizeAction(a.name).includes(normalizedResponseAction) || // the || is kind of a fuzzy match
          normalizedResponseAction.includes(normalizeAction(a.name))
          //
        );
        if (action) {
          this.runtimeLogger.debug(`Success: Found action: ${action?.name}`);
        } else {
          this.runtimeLogger.debug("Attempting to find action in similes.");
          for (const _action of this.actions) {
            const simileAction = _action.similes?.find(
              (simile) => simile.toLowerCase().replace("_", "").includes(normalizedResponseAction) || normalizedResponseAction.includes(simile.toLowerCase().replace("_", ""))
            );
            if (simileAction) {
              action = _action;
              this.runtimeLogger.debug(`Success: Action found in similes: ${action.name}`);
              break;
            }
          }
        }
        if (!action) {
          this.runtimeLogger.error(`No action found for: ${responseAction}`);
          continue;
        }
        if (!action.handler) {
          this.runtimeLogger.error(`Action ${action.name} has no handler.`);
          continue;
        }
        try {
          this.runtimeLogger.debug(`Executing handler for action: ${action.name}`);
          await action.handler(this, message, state, {}, callback, responses);
          this.runtimeLogger.debug(`Success: Action ${action.name} executed successfully.`);
          this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: "action",
            body: {
              action: action.name,
              message: message.content.text,
              messageId: message.id,
              state,
              responses
            }
          });
        } catch (error) {
          this.runtimeLogger.error(error);
          throw error;
        }
      }
    }
  }
  /**
   * Evaluate the message and state using the registered evaluators.
   * @param message The message to evaluate.
   * @param state The state of the agent.
   * @param didRespond Whether the agent responded to the message.~
   * @param callback The handler callback
   * @returns The results of the evaluation.
   */
  async evaluate(message, state, didRespond, callback, responses) {
    const evaluatorPromises = this.evaluators.map(async (evaluator) => {
      if (!evaluator.handler) {
        return null;
      }
      if (!didRespond && !evaluator.alwaysRun) {
        return null;
      }
      const result = await evaluator.validate(this, message, state);
      if (result) {
        return evaluator;
      }
      return null;
    });
    const evaluators = (await Promise.all(evaluatorPromises)).filter(Boolean);
    if (evaluators.length === 0) {
      return [];
    }
    state = await this.composeState(message, ["RECENT_MESSAGES", "EVALUATORS"]);
    await Promise.all(
      evaluators.map(async (evaluator) => {
        if (evaluator.handler) {
          await evaluator.handler(this, message, state, {}, callback, responses);
          this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: "evaluator",
            body: {
              evaluator: evaluator.name,
              messageId: message.id,
              message: message.content.text,
              state
            }
          });
        }
      })
    );
    return evaluators;
  }
  async ensureConnection({
    entityId,
    roomId,
    userName,
    name,
    source,
    type,
    channelId,
    serverId,
    worldId,
    userId
  }) {
    if (entityId === this.agentId) {
      throw new Error("Agent should not connect to itself");
    }
    if (!worldId && serverId) {
      worldId = createUniqueUuid(this, serverId);
    }
    const names3 = [name, userName].filter(Boolean);
    const metadata = {
      [source]: {
        id: userId,
        name,
        userName
      }
    };
    try {
      let entity = await this.adapter.getEntityById(entityId);
      if (!entity) {
        try {
          const success = await this.adapter.createEntity({
            id: entityId,
            names: names3,
            metadata,
            agentId: this.agentId
          });
          if (success) {
            this.runtimeLogger.debug(
              `Created new entity ${entityId} for user ${name || userName || "unknown"}`
            );
          } else {
            throw new Error(`Failed to create entity ${entityId}`);
          }
        } catch (error) {
          if (error.message?.includes("duplicate key") || error.code === "23505") {
            this.runtimeLogger.debug(
              `Entity ${entityId} exists in database but not for this agent. This is normal in multi-agent setups.`
            );
          } else {
            throw error;
          }
        }
      } else {
        await this.adapter.updateEntity({
          id: entityId,
          names: [.../* @__PURE__ */ new Set([...entity.names || [], ...names3])].filter(Boolean),
          metadata: {
            ...entity.metadata,
            [source]: {
              ...entity.metadata?.[source],
              name,
              userName
            }
          },
          agentId: this.agentId
        });
      }
      if (worldId) {
        await this.ensureWorldExists({
          id: worldId,
          name: serverId ? `World for server ${serverId}` : `World for room ${roomId}`,
          agentId: this.agentId,
          serverId: serverId || "default",
          metadata
        });
      }
      await this.ensureRoomExists({
        id: roomId,
        name,
        source,
        type,
        channelId,
        serverId,
        worldId
      });
      try {
        await this.ensureParticipantInRoom(entityId, roomId);
      } catch (error) {
        if (error.message?.includes("not found")) {
          const added = await this.adapter.addParticipant(entityId, roomId);
          if (!added) {
            throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);
          }
          this.runtimeLogger.debug(`Added participant ${entityId} to room ${roomId} directly`);
        } else {
          throw error;
        }
      }
      await this.ensureParticipantInRoom(this.agentId, roomId);
      this.runtimeLogger.debug(
        `Success: Successfully connected entity ${entityId} in room ${roomId}`
      );
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to ensure connection: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }
  /**
   * Ensures a participant is added to a room, checking that the entity exists first
   */
  async ensureParticipantInRoom(entityId, roomId) {
    const entity = await this.adapter.getEntityById(entityId);
    if (!entity && entityId !== this.agentId) {
      this.runtimeLogger.warn(
        `Entity ${entityId} not directly accessible to agent ${this.agentId}. Will attempt to add as participant anyway.`
      );
    } else if (!entity) {
      throw new Error(`User ${entityId} not found`);
    }
    const participants = await this.adapter.getParticipantsForRoom(roomId);
    if (!participants.includes(entityId)) {
      const added = await this.adapter.addParticipant(entityId, roomId);
      if (!added) {
        throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);
      }
      if (entityId === this.agentId) {
        this.runtimeLogger.debug(
          `Agent ${this.character.name} linked to room ${roomId} successfully.`
        );
      } else {
        this.runtimeLogger.debug(`User ${entityId} linked to room ${roomId} successfully.`);
      }
    }
  }
  async removeParticipant(entityId, roomId) {
    return await this.adapter.removeParticipant(entityId, roomId);
  }
  async getParticipantsForEntity(entityId) {
    return await this.adapter.getParticipantsForEntity(entityId);
  }
  async getParticipantsForRoom(roomId) {
    return await this.adapter.getParticipantsForRoom(roomId);
  }
  async addParticipant(entityId, roomId) {
    return await this.adapter.addParticipant(entityId, roomId);
  }
  /**
   * Ensure the existence of a world.
   */
  async ensureWorldExists({ id, name, serverId, metadata }) {
    const world = await this.getWorld(id);
    if (!world) {
      this.runtimeLogger.debug("Creating world:", {
        id,
        name,
        serverId,
        agentId: this.agentId
      });
      await this.adapter.createWorld({
        id,
        name,
        agentId: this.agentId,
        serverId: serverId || "default",
        metadata
      });
      this.runtimeLogger.debug(`World ${id} created successfully.`);
    }
  }
  /**
   * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user
   * and agent are added as participants. The room ID is returned.
   * @param entityId - The user ID to create a room with.
   * @returns The room ID of the room between the agent and the user.
   * @throws An error if the room cannot be created.
   */
  async ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }) {
    const room = await this.adapter.getRoom(id);
    if (!room) {
      await this.adapter.createRoom({
        id,
        name,
        agentId: this.agentId,
        source,
        type,
        channelId,
        serverId,
        worldId,
        metadata
      });
      this.runtimeLogger.debug(`Room ${id} created successfully.`);
    }
  }
  /**
   * Composes the agent's state by gathering data from enabled providers.
   * @param message - The message to use as context for state composition
   * @param filterList - Optional list of provider names to include, filtering out all others
   * @param includeList - Optional list of private provider names to include that would otherwise be filtered out
   * @returns A State object containing provider data, values, and text
   */
  async composeState(message, filterList = null, includeList = null) {
    const cachedState = await this.stateCache.get(message.id) || {
      values: {},
      data: {},
      text: ""
    };
    const existingProviderNames = cachedState.data.providers ? Object.keys(cachedState.data.providers) : [];
    const providerNames = /* @__PURE__ */ new Set();
    if (filterList && filterList.length > 0) {
      filterList.forEach((name) => providerNames.add(name));
    } else {
      this.providers.filter((p) => !p.private && !p.dynamic && !existingProviderNames.includes(p.name)).forEach((p) => providerNames.add(p.name));
    }
    if (includeList && includeList.length > 0) {
      includeList.forEach((name) => providerNames.add(name));
    }
    const providersToGet = Array.from(
      new Set(this.providers.filter((p) => providerNames.has(p.name)))
    ).sort((a, b) => (a.position || 0) - (b.position || 0));
    const providerData = await Promise.all(
      providersToGet.map(async (provider) => {
        const start = Date.now();
        const result = await provider.get(this, message, cachedState);
        const duration = Date.now() - start;
        this.runtimeLogger.debug(`${provider.name} Provider took ${duration}ms to respond`);
        return {
          ...result,
          providerName: provider.name
        };
      })
    );
    const existingProviderData = cachedState.data.providers || {};
    const combinedValues = { ...existingProviderData };
    for (const result of providerData) {
      combinedValues[result.providerName] = result.values || {};
    }
    const newProvidersText = providerData.map((result) => result.text).filter((text) => text !== "").join("\n");
    let providersText = "";
    if (cachedState.text && newProvidersText) {
      providersText = `${cachedState.text}
${newProvidersText}`;
    } else if (newProvidersText) {
      providersText = newProvidersText;
    } else if (cachedState.text) {
      providersText = cachedState.text;
    }
    const values = {
      ...cachedState.values || {}
    };
    for (const providerName in combinedValues) {
      const providerValues = combinedValues[providerName];
      if (providerValues && typeof providerValues === "object") {
        Object.assign(values, providerValues);
      }
    }
    const newState = {
      values: {
        ...values,
        providers: providersText
      },
      data: {
        ...cachedState.data || {},
        providers: combinedValues
      },
      text: providersText
    };
    this.stateCache.set(message.id, newState);
    return newState;
  }
  getService(service) {
    const serviceInstance = this.services.get(service);
    if (!serviceInstance) {
      this.runtimeLogger.warn(`Service ${service} not found`);
      return null;
    }
    return serviceInstance;
  }
  async registerService(service) {
    const serviceType = service.serviceType;
    if (!serviceType) {
      return;
    }
    this.runtimeLogger.debug(
      `${this.character.name}(${this.agentId}) - Registering service:`,
      serviceType
    );
    if (this.services.has(serviceType)) {
      this.runtimeLogger.warn(
        `${this.character.name}(${this.agentId}) - Service ${serviceType} is already registered. Skipping registration.`
      );
      return;
    }
    const serviceInstance = await service.start(this);
    this.services.set(serviceType, serviceInstance);
    this.runtimeLogger.debug(
      `${this.character.name}(${this.agentId}) - Service ${serviceType} registered successfully`
    );
  }
  registerModel(modelType, handler) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType[modelType];
    if (!this.models.has(modelKey)) {
      this.models.set(modelKey, []);
    }
    this.models.get(modelKey)?.push(handler);
  }
  getModel(modelType) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType[modelType];
    const models = this.models.get(modelKey);
    if (!models?.length) {
      return void 0;
    }
    return models[0];
  }
  /**
   * Use a model with strongly typed parameters and return values based on model type
   * @template T - The model type to use
   * @template R - The expected return type, defaults to the type defined in ModelResultMap[T]
   * @param {T} modelType - The type of model to use
   * @param {ModelParamsMap[T] | any} params - The parameters for the model, typed based on model type
   * @returns {Promise<R>} - The model result, typed based on the provided generic type parameter
   */
  async useModel(modelType, params) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType[modelType];
    const model = this.getModel(modelKey);
    if (!model) {
      throw new Error(`No handler found for delegate type: ${modelKey}`);
    }
    this.runtimeLogger.debug(`[useModel] ${modelKey} input:`, JSON.stringify(params, null, 2));
    let paramsWithRuntime;
    if (params === null || params === void 0 || typeof params !== "object" || Array.isArray(params) || typeof Buffer !== "undefined" && Buffer.isBuffer(params)) {
      paramsWithRuntime = params;
    } else {
      paramsWithRuntime = {
        ...params,
        runtime: this
      };
    }
    const startTime = performance.now();
    const response = await model(this, paramsWithRuntime);
    const elapsedTime = performance.now() - startTime;
    this.runtimeLogger.debug(`[useModel] ${modelKey} completed in ${elapsedTime.toFixed(2)}ms`);
    this.runtimeLogger.debug(
      `[useModel] ${modelKey} output:`,
      // if response is an array, should the first and last 5 items with a "..." in the middle, and a (x items) at the end
      Array.isArray(response) ? `${JSON.stringify(response.slice(0, 5))}...${JSON.stringify(
        response.slice(-5)
      )} (${response.length} items)` : JSON.stringify(response)
    );
    this.adapter.log({
      entityId: this.agentId,
      roomId: this.agentId,
      body: {
        modelType,
        modelKey,
        params: params ? typeof params === "object" ? Object.keys(params) : typeof params : null,
        response: Array.isArray(response) && response.every((x) => typeof x === "number") ? "[array]" : response
      },
      type: `useModel:${modelKey}`
    });
    return response;
  }
  registerEvent(event, handler) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)?.push(handler);
  }
  getEvent(event) {
    return this.events.get(event);
  }
  async emitEvent(event, params) {
    const events = Array.isArray(event) ? event : [event];
    for (const eventName of events) {
      const eventHandlers = this.events.get(eventName);
      if (eventHandlers) {
        await Promise.all(eventHandlers.map((handler) => handler(params)));
      }
    }
  }
  async ensureEmbeddingDimension() {
    this.runtimeLogger.debug(
      `[AgentRuntime][${this.character.name}] Starting ensureEmbeddingDimension`
    );
    if (!this.adapter) {
      throw new Error(
        `[AgentRuntime][${this.character.name}] Database adapter not initialized before ensureEmbeddingDimension`
      );
    }
    try {
      const model = this.getModel(ModelType.TEXT_EMBEDDING);
      if (!model) {
        throw new Error(
          `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered`
        );
      }
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Getting embedding dimensions`
      );
      const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, null);
      if (!embedding || !embedding.length) {
        throw new Error(`[AgentRuntime][${this.character.name}] Invalid embedding received`);
      }
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Setting embedding dimension: ${embedding.length}`
      );
      await this.adapter.ensureEmbeddingDimension(embedding.length);
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Successfully set embedding dimension`
      );
    } catch (error) {
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Error in ensureEmbeddingDimension:`,
        error
      );
      throw error;
    }
  }
  registerTaskWorker(taskHandler) {
    if (this.taskWorkers.has(taskHandler.name)) {
      this.runtimeLogger.warn(
        `Task definition ${taskHandler.name} already registered. Will be overwritten.`
      );
    }
    this.taskWorkers.set(taskHandler.name, taskHandler);
  }
  /**
   * Get a task worker by name
   */
  getTaskWorker(name) {
    return this.taskWorkers.get(name);
  }
  // Implement database adapter methods
  get db() {
    return this.adapter.db;
  }
  async init() {
    await this.adapter.init();
  }
  async close() {
    await this.adapter.close();
  }
  async getAgent(agentId) {
    return await this.adapter.getAgent(agentId);
  }
  async getAgents() {
    return await this.adapter.getAgents();
  }
  async createAgent(agent) {
    return await this.adapter.createAgent(agent);
  }
  async updateAgent(agentId, agent) {
    return await this.adapter.updateAgent(agentId, agent);
  }
  async deleteAgent(agentId) {
    return await this.adapter.deleteAgent(agentId);
  }
  async ensureAgentExists(agent) {
    await this.adapter.ensureAgentExists(agent);
  }
  async getEntityById(entityId) {
    return await this.adapter.getEntityById(entityId);
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return await this.adapter.getEntitiesForRoom(roomId, includeComponents);
  }
  async createEntity(entity) {
    if (!entity.agentId) {
      entity.agentId = this.agentId;
    }
    return await this.adapter.createEntity(entity);
  }
  async updateEntity(entity) {
    await this.adapter.updateEntity(entity);
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return await this.adapter.getComponent(entityId, type, worldId, sourceEntityId);
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return await this.adapter.getComponents(entityId, worldId, sourceEntityId);
  }
  async createComponent(component) {
    return await this.adapter.createComponent(component);
  }
  async updateComponent(component) {
    await this.adapter.updateComponent(component);
  }
  async deleteComponent(componentId) {
    await this.adapter.deleteComponent(componentId);
  }
  async addEmbeddingToMemory(memory) {
    if (memory.embedding) {
      return memory;
    }
    const memoryText = memory.content.text;
    if (!memoryText) {
      throw new Error("Cannot generate embedding: Memory content is empty");
    }
    try {
      memory.embedding = await this.useModel(ModelType.TEXT_EMBEDDING, {
        text: memoryText
      });
    } catch (error) {
      logger_default.error("Failed to generate embedding:", error);
      memory.embedding = await this.useModel(ModelType.TEXT_EMBEDDING, null);
    }
    return memory;
  }
  async getMemories(params) {
    return await this.adapter.getMemories(params);
  }
  async getMemoryById(id) {
    return await this.adapter.getMemoryById(id);
  }
  async getMemoriesByIds(ids, tableName) {
    return await this.adapter.getMemoriesByIds(ids, tableName);
  }
  async getMemoriesByRoomIds(params) {
    return await this.adapter.getMemoriesByRoomIds(params);
  }
  async getCachedEmbeddings(params) {
    return await this.adapter.getCachedEmbeddings(params);
  }
  async log(params) {
    await this.adapter.log(params);
  }
  async searchMemories(params) {
    return await this.adapter.searchMemories(params);
  }
  async createMemory(memory, tableName, unique) {
    return await this.adapter.createMemory(memory, tableName, unique);
  }
  async updateMemory(memory) {
    return await this.adapter.updateMemory(memory);
  }
  async deleteMemory(memoryId) {
    await this.adapter.deleteMemory(memoryId);
  }
  async deleteAllMemories(roomId, tableName) {
    await this.adapter.deleteAllMemories(roomId, tableName);
  }
  async countMemories(roomId, unique, tableName) {
    return await this.adapter.countMemories(roomId, unique, tableName);
  }
  async getLogs(params) {
    return await this.adapter.getLogs(params);
  }
  async deleteLog(logId) {
    await this.adapter.deleteLog(logId);
  }
  async createWorld(world) {
    return await this.adapter.createWorld(world);
  }
  async getWorld(id) {
    return await this.adapter.getWorld(id);
  }
  async getAllWorlds() {
    return await this.adapter.getAllWorlds();
  }
  async updateWorld(world) {
    await this.adapter.updateWorld(world);
  }
  async getRoom(roomId) {
    return await this.adapter.getRoom(roomId);
  }
  async createRoom({ id, name, source, type, channelId, serverId, worldId }) {
    return await this.adapter.createRoom({
      id,
      name,
      source,
      type,
      channelId,
      serverId,
      worldId
    });
  }
  async deleteRoom(roomId) {
    await this.adapter.deleteRoom(roomId);
  }
  async updateRoom(room) {
    await this.adapter.updateRoom(room);
  }
  async getRoomsForParticipant(entityId) {
    return await this.adapter.getRoomsForParticipant(entityId);
  }
  async getRoomsForParticipants(userIds) {
    return await this.adapter.getRoomsForParticipants(userIds);
  }
  async getRooms(worldId) {
    return await this.adapter.getRooms(worldId);
  }
  async getParticipantUserState(roomId, entityId) {
    return await this.adapter.getParticipantUserState(roomId, entityId);
  }
  async setParticipantUserState(roomId, entityId, state) {
    await this.adapter.setParticipantUserState(roomId, entityId, state);
  }
  async createRelationship(params) {
    return await this.adapter.createRelationship(params);
  }
  async updateRelationship(relationship) {
    await this.adapter.updateRelationship(relationship);
  }
  async getRelationship(params) {
    return await this.adapter.getRelationship(params);
  }
  async getRelationships(params) {
    return await this.adapter.getRelationships(params);
  }
  async getCache(key) {
    return await this.adapter.getCache(key);
  }
  async setCache(key, value) {
    return await this.adapter.setCache(key, value);
  }
  async deleteCache(key) {
    return await this.adapter.deleteCache(key);
  }
  async createTask(task) {
    return await this.adapter.createTask(task);
  }
  async getTasks(params) {
    return await this.adapter.getTasks(params);
  }
  async getTask(id) {
    return await this.adapter.getTask(id);
  }
  async getTasksByName(name) {
    return await this.adapter.getTasksByName(name);
  }
  async updateTask(id, task) {
    await this.adapter.updateTask(id, task);
  }
  async deleteTask(id) {
    await this.adapter.deleteTask(id);
  }
  // Event emitter methods
  on(event, callback) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, []);
    }
    this.eventHandlers.get(event).push(callback);
  }
  off(event, callback) {
    if (!this.eventHandlers.has(event)) {
      return;
    }
    const handlers = this.eventHandlers.get(event);
    const index = handlers.indexOf(callback);
    if (index !== -1) {
      handlers.splice(index, 1);
    }
  }
  emit(event, data) {
    if (!this.eventHandlers.has(event)) {
      return;
    }
    for (const handler of this.eventHandlers.get(event)) {
      handler(data);
    }
  }
};

// src/settings.ts
import crypto from "crypto-browserify";
function createSettingFromConfig(configSetting) {
  return {
    name: configSetting.name,
    description: configSetting.description,
    usageDescription: configSetting.usageDescription || "",
    value: null,
    required: configSetting.required,
    validation: configSetting.validation || null,
    public: configSetting.public || false,
    secret: configSetting.secret || false,
    dependsOn: configSetting.dependsOn || [],
    onSetAction: configSetting.onSetAction || null,
    visibleIf: configSetting.visibleIf || null
  };
}
function getSalt() {
  const secretSalt = (typeof process !== "undefined" ? process.env.SECRET_SALT : import.meta.env.SECRET_SALT) || "secretsalt";
  if (!secretSalt) {
    logger.error("SECRET_SALT is not set");
  }
  const salt = secretSalt;
  logger.debug(`Generated salt with length: ${salt.length} (truncated for security)`);
  return salt;
}
function encryptStringValue(value, salt) {
  try {
    if (value === void 0 || value === null) {
      logger.debug("Attempted to encrypt undefined or null value");
      return value;
    }
    if (typeof value === "boolean" || typeof value === "number") {
      logger.debug("Value is a boolean or number, returning as is");
      return value;
    }
    const parts = value.split(":");
    if (parts.length === 2) {
      try {
        const possibleIv = Buffer.from(parts[0], "hex");
        if (possibleIv.length === 16) {
          logger.debug("Value appears to be already encrypted, skipping re-encryption");
          return value;
        }
      } catch (e) {
      }
    }
    const key = crypto.createHash("sha256").update(salt).digest().slice(0, 32);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
    let encrypted = cipher.update(value, "utf8", "hex");
    encrypted += cipher.final("hex");
    return `${iv.toString("hex")}:${encrypted}`;
  } catch (error) {
    logger.error(`Error encrypting value: ${error}`);
    return value;
  }
}
function decryptStringValue(value, salt) {
  try {
    if (value === void 0 || value === null) {
      logger.debug("Attempted to decrypt undefined or null value");
      return value;
    }
    if (typeof value === "boolean" || typeof value === "number") {
      logger.debug("Value is a boolean or number, returning as is");
      return value;
    }
    const parts = value.split(":");
    if (parts.length !== 2) {
      logger.debug(
        `Invalid encrypted value format - expected 'iv:encrypted', returning original value`
      );
      return value;
    }
    const iv = Buffer.from(parts[0], "hex");
    const encrypted = parts[1];
    if (iv.length !== 16) {
      logger.debug(`Invalid IV length (${iv.length}) - expected 16 bytes`);
      return value;
    }
    const key = crypto.createHash("sha256").update(salt).digest().slice(0, 32);
    const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  } catch (error) {
    logger.error(`Error decrypting value: ${error}`);
    return value;
  }
}
function saltSettingValue(setting, salt) {
  const settingCopy = { ...setting };
  if (setting.secret === true && typeof setting.value === "string" && setting.value) {
    settingCopy.value = encryptStringValue(setting.value, salt);
  }
  return settingCopy;
}
function unsaltSettingValue(setting, salt) {
  const settingCopy = { ...setting };
  if (setting.secret === true && typeof setting.value === "string" && setting.value) {
    settingCopy.value = decryptStringValue(setting.value, salt);
  }
  return settingCopy;
}
function saltWorldSettings(worldSettings, salt) {
  const saltedSettings = {};
  for (const [key, setting] of Object.entries(worldSettings)) {
    saltedSettings[key] = saltSettingValue(setting, salt);
  }
  return saltedSettings;
}
function unsaltWorldSettings(worldSettings, salt) {
  const unsaltedSettings = {};
  for (const [key, setting] of Object.entries(worldSettings)) {
    unsaltedSettings[key] = unsaltSettingValue(setting, salt);
  }
  return unsaltedSettings;
}
async function updateWorldSettings(runtime, serverId, worldSettings) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world) {
      logger.error(`No world found for server ${serverId}`);
      return false;
    }
    if (!world.metadata) {
      world.metadata = {};
    }
    const salt = getSalt();
    const saltedSettings = saltWorldSettings(worldSettings, salt);
    world.metadata.settings = saltedSettings;
    await runtime.updateWorld(world);
    return true;
  } catch (error) {
    logger.error(`Error updating settings state: ${error}`);
    return false;
  }
}
async function getWorldSettings(runtime, serverId) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world || !world.metadata?.settings) {
      return null;
    }
    const saltedSettings = world.metadata.settings;
    const salt = getSalt();
    return unsaltWorldSettings(saltedSettings, salt);
  } catch (error) {
    logger.error(`Error getting settings state: ${error}`);
    return null;
  }
}
async function initializeOnboarding(runtime, world, config) {
  try {
    if (world.metadata?.settings) {
      logger.info(`Onboarding state already exists for server ${world.serverId}`);
      const saltedSettings = world.metadata.settings;
      const salt = getSalt();
      return unsaltWorldSettings(saltedSettings, salt);
    }
    const worldSettings = {};
    if (config.settings) {
      for (const [key, configSetting] of Object.entries(config.settings)) {
        worldSettings[key] = createSettingFromConfig(configSetting);
      }
    }
    if (!world.metadata) {
      world.metadata = {};
    }
    world.metadata.settings = worldSettings;
    await runtime.updateWorld(world);
    logger.info(`Initialized settings config for server ${world.serverId}`);
    return worldSettings;
  } catch (error) {
    logger.error(`Error initializing settings config: ${error}`);
    return null;
  }
}
function encryptedCharacter(character) {
  const encryptedChar = JSON.parse(JSON.stringify(character));
  const salt = getSalt();
  if (encryptedChar.settings?.secrets) {
    encryptedChar.settings.secrets = encryptObjectValues(encryptedChar.settings.secrets, salt);
  }
  if (encryptedChar.secrets) {
    encryptedChar.secrets = encryptObjectValues(encryptedChar.secrets, salt);
  }
  return encryptedChar;
}
function decryptedCharacter(character, runtime) {
  const decryptedChar = JSON.parse(JSON.stringify(character));
  const salt = getSalt();
  if (decryptedChar.settings?.secrets) {
    decryptedChar.settings.secrets = decryptObjectValues(decryptedChar.settings.secrets, salt);
  }
  if (decryptedChar.secrets) {
    decryptedChar.secrets = decryptObjectValues(decryptedChar.secrets, salt);
  }
  return decryptedChar;
}
function encryptObjectValues(obj, salt) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && value) {
      result[key] = encryptStringValue(value, salt);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function decryptObjectValues(obj, salt) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && value) {
      result[key] = decryptStringValue(value, salt);
    } else {
      result[key] = value;
    }
  }
  return result;
}

// src/audioUtils.ts
import pkg from "stream-browserify";
import { Buffer as Buffer2 } from "buffer";
var { PassThrough, Readable } = pkg;
function getWavHeader(audioLength, sampleRate, channelCount = 1, bitsPerSample = 16) {
  const wavHeader = Buffer2.alloc(44);
  wavHeader.write("RIFF", 0);
  wavHeader.writeUInt32LE(36 + audioLength, 4);
  wavHeader.write("WAVE", 8);
  wavHeader.write("fmt ", 12);
  wavHeader.writeUInt32LE(16, 16);
  wavHeader.writeUInt16LE(1, 20);
  wavHeader.writeUInt16LE(channelCount, 22);
  wavHeader.writeUInt32LE(sampleRate, 24);
  wavHeader.writeUInt32LE(sampleRate * bitsPerSample * channelCount / 8, 28);
  wavHeader.writeUInt16LE(bitsPerSample * channelCount / 8, 32);
  wavHeader.writeUInt16LE(bitsPerSample, 34);
  wavHeader.write("data", 36);
  wavHeader.writeUInt32LE(audioLength, 40);
  return wavHeader;
}
function prependWavHeader(readable, audioLength, sampleRate, channelCount = 1, bitsPerSample = 16) {
  const wavHeader = getWavHeader(audioLength, sampleRate, channelCount, bitsPerSample);
  let pushedHeader = false;
  const passThrough = new PassThrough();
  readable.on("data", (data) => {
    if (!pushedHeader) {
      passThrough.push(wavHeader);
      pushedHeader = true;
    }
    passThrough.push(data);
  });
  readable.on("end", () => {
    passThrough.end();
  });
  return passThrough;
}
export {
  AgentRuntime,
  AgentStatus,
  CacheKeyPrefix,
  ChannelType,
  DatabaseAdapter,
  EventType,
  KnowledgeScope,
  MemoryType,
  ModelType,
  PlatformPrefix,
  Role,
  SOCKET_MESSAGE_TYPE,
  Semaphore,
  Service,
  ServiceType,
  TEEMode,
  TeeType,
  VECTOR_DIMS,
  addHeader,
  asUUID,
  booleanFooter,
  cleanJsonResponse,
  composeActionExamples,
  composePrompt,
  composePromptFromState,
  composeRandomUser,
  createMessageMemory,
  createServiceError,
  createSettingFromConfig,
  createUniqueUuid,
  decryptObjectValues,
  decryptStringValue as decryptSecret,
  decryptStringValue,
  decryptedCharacter,
  dynamicImport,
  elizaLogger,
  encryptObjectValues,
  encryptStringValue,
  encryptedCharacter,
  extractAttributes,
  findEntityByName,
  findWorldsForOwner,
  formatActionNames,
  formatActions,
  formatEntities,
  formatMessages,
  formatPosts,
  formatTimestamp,
  getBrowserService,
  getEntityDetails,
  getFileService,
  getMemoryText,
  getPdfService,
  getSalt,
  getTypedService,
  getUserServerRole,
  getVideoService,
  getWavHeader,
  getWorldSettings,
  handlePluginImporting,
  initializeOnboarding,
  isCustomMetadata,
  isDescriptionMetadata,
  isDocumentMemory,
  isDocumentMetadata,
  isFragmentMemory,
  isFragmentMetadata,
  isMessageMetadata,
  logger,
  messageHandlerTemplate,
  normalizeJsonString,
  parseActionResponseFromText,
  parseBooleanFromText2 as parseBooleanFromText,
  parseJSONObjectFromText,
  parseJsonArrayFromText,
  postActionResponseFooter,
  postCreationTemplate,
  prependWavHeader,
  registerDynamicImport,
  saltSettingValue,
  saltWorldSettings,
  shouldRespondTemplate,
  splitChunks,
  stringArrayFooter,
  stringToUuid,
  trimTokens,
  truncateToCompleteSentence,
  unsaltSettingValue,
  unsaltWorldSettings,
  updateWorldSettings,
  uuidSchema,
  validateUuid
};
